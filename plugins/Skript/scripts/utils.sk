# === Utils ===

import:
    com.camden.skriptutils.Dict

# === Universal Constants ===

options:
    spawn: "8.5, 0, 8.5"
    world_name: "world"
    menu_enum: "menu"
    lobby_enum: "lobby"
    in_game_enum: "in_game"
    user_enum: "user"
    unset: "___unset___"  # Special! Used to signify difference from `null`

# === Exports ===

function export_world_name() :: text:
    return {@world_name}

function export_menu_enum() :: text:
    return {@menu_enum}

function export_lobby_enum() :: text:
    return {@lobby_enum}

function export_in_game_enum() :: text:
    return {@in_game_enum}

function export_user_enum() :: text:
    return {@user_enum}

# === General Utils ===

function is_null(object: object) :: boolean:
    set {_list::*} to "null" and "<none>"
    if {_list::*} contains "%{_object}%":
        return true
    return false

function convert_to_skript_list(list: object) :: texts:
    set {_string} to "%{_list}%"  # Convert to string...
    set {_length} to length of {_string}
    set {_trim} to substring of {_string} from 2 to {_length} - 1
    set {_split::*} to {_trim} split at ", "
    return {_split::*}

function get_keys_from_metadata(metadata: text) :: texts:
    set {_dict} to Dict.deserialize({_metadata})
    set {_keys_list} to {_dict}.getKeys()
    set {_keys::*} to convert_to_skript_list({_keys_list})
    return {_keys::*}

function _util_key(target: object) :: objects:
    set {_stop} to true
    clear {_prefix}

    if {game::%{_target}%::metadata} is set:
        set {_prefix} to "game"
        set {_stop} to false

    set {_target} to "%{_target}%"  # Convert to string...
    if {level::%{_target}%::metadata} is set:
        set {_prefix} to "level"
        set {_stop} to false
    
    set {_returns::*} to {_stop} and {_prefix}
    return {_returns::*}

# Emulate's Python's maxsplit=1...
function _get_rest(split: texts) :: text:
    set {_rest} to ""
    loop {_split::*}:
        set {_index} to loop-index parsed as number
        if {_index} is 1:
            continue

        set {_suffix} to loop-value
        if {_rest} is not empty:
            set {_suffix} to join "." and loop-value
        set {_rest} to join {_rest} and {_suffix}

    return {_rest}

function _recurse_get(dict: object, key: text, default: object) :: object:
    set {_split::*} to {_key} split at "."
    set {_k} to {_split::1}

    # If length == 1...
    set {_length} to size of {_split::*}
    if {_length} is 1:
        if {_default} is {@unset}:
            return {_dict}.get({_k})
        # Technically could be a `LinkedHashMap`
        return {_dict}.getOrDefault({_k}, {_default})

    # Recurse into inner `LinkedHashMap`
    set {_inner_dict} to {_dict}.get({_k})
    set {_rest} to _get_rest({_split::*})
    return _recurse_get({_inner_dict}, {_rest}, {_default})

function _recurse_set(dict: object, key: text, val: object) :: object:
    set {_split::*} to {_key} split at "."
    set {_k} to {_split::1}  # Exception if size is 0?

    # If length == 1...
    set {_length} to size of {_split::*}
    if {_length} is 1:
        {_dict}.put({_k}, {_val})
        return {_dict}

    # Technically a `LinkedHashMap`
    set {_inner_dict} to {_dict}.get({_k})  # Exception if key does not exist?

    set {_rest} to _get_rest({_split::*})
    set {_inner_dict} to _recurse_set({_inner_dict}, {_rest}, {_val})

    {_dict}.put({_k}, {_inner_dict})
    return {_dict}

function get_key(target: object, key: text, default: object = {@unset}) :: object:
    set {_tuple::*} to _util_key({_target})
    set {_stop} to {_tuple::1}
    set {_prefix} to {_tuple::2}

    # Edge-case: not set...
    if {_stop} is true:
        stop

    set {_metadata} to {%{_prefix}%::%{_target}%::metadata}
    set {_dict} to Dict.deserialize({_metadata})
    return _recurse_get({_dict}, {_key}, {_default})

function set_key(target: object, key: text, val: object):
    set {_tuple::*} to _util_key({_target})
    set {_stop} to {_tuple::1}
    set {_prefix} to {_tuple::2}

    # Edge-case: not set...
    if {_stop} is true:
        stop

    # Edge-case: Skript stringified null...
    if is_null({_val}) is true:
        set {_val} to null

    set {_metadata} to {%{_prefix}%::%{_target}%::metadata}
    set {_dict} to Dict.deserialize({_metadata})
    set {_dict} to _recurse_set({_dict}, {_key}, {_val})
    set {_serialized} to {_dict}.serialize()
    set {%{_prefix}%::%{_target}%::metadata} to {_serialized}

function format_message(prefix: text, message: text, color: text = "white", square_brackets: boolean = true) :: text:
    set {_color} to formatted "<%{_color}%>"

    set {_bracket_1} to "["
    set {_bracket_2} to "]"
    if {_square_brackets} is false:
        set {_bracket_1} to "<"
        set {_bracket_2} to ">"

    return "<gray>%{_bracket_1}%%{_color}%%{_prefix}%<gray>%{_bracket_2}% <reset>%{_message}%"

function is_dev(player: player) :: boolean:
    return get_key({_player}, "dev_mode")

function _tp(player: player, x: number, y: number, z: number, yaw: object = null, world_name: text = {@world_name}):
    set {_location} to location {_x}, {_y}, {_z} in world {_world_name}
    if is_null({_yaw}) is false:
        set {_yaw} to {_yaw} parsed as number
        set yaw of {_location} to {_yaw}

    teleport {_player} to {_location}

function tp_to_spawn(player: player):
    set {_split::*} to {@spawn} split at ", "
    set {_x} to {_split::1} parsed as number
    set {_y} to {_split::2} parsed as number
    set {_z} to {_split::3} parsed as number
    _tp({_player}, {_x}, {_y}, {_z})

function in_menu(player: player) :: boolean:
    set {_status} to get_key({_player}, "status")
    if {_status} is {@menu_enum}:
        return true
    return false    

function in_lobby(player: player) :: boolean:
    set {_status} to get_key({_player}, "status")
    if {_status} is {@lobby_enum}:
        return true
    return false

function in_game(player: player, strict: boolean = false) :: boolean:
    if {_strict} is false:
        if in_lobby({_player}) is true:
            return true
    set {_status} to get_key({_player}, "status")
    if {_status} is {@in_game_enum}:
        return true
    return false
