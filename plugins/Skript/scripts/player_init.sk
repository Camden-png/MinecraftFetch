# === Player Initialization ===

import:
    com.camden.skriptutils.Dict

function _reset_player(player: player):
    set_key({_player}, "status", null)
    set_key({_player}, "is_ready", false)
    set {_gm} to get_key({_player}, "prev_gm")
    if is_null({_gm}) is false:
        set {_gm} to {_gm} parsed as gamemode
        set gamemode of {_player} to {_gm}
        set_key({_player}, "prev_gm", null)
    clear inventory of {_player}
    tp_to_spawn({_player})

function init_player(player: player):
    if {game::%{_player}%::metadata} is set:
        if in_game({_player}) is true:
            _reset_player({_player})

    set {_dict} to new Dict()
    set {_is_dev} to false
    if {_player} is op:
        set {_is_dev} to true
    {_dict}.put("dev_mode", {_is_dev})
    {_dict}.put("prev_gm", null)
    {_dict}.put("level", null)
    {_dict}.put("status", null)  # Enum...
    {_dict}.put("is_ready", false)
    {_dict}.put("has_bone", false)

    set {_serialized} to {_dict}.serialize()
    set {game::%{_player}%::metadata} to {_serialized}

# === Connect / Disconnect ===

on join:
    init_player(player)
    set join message to "<gray>[<orange>Login<gray>] <reset>%player% logged in!"

on quit:
    set quit message to "<gray>[<orange>Logout<gray>] <reset>%player% logged out!"

# Prevent players from modifying the world...
on break:
    if player is op:
        if in_game(player) is false:
            stop
    cancel event

on place:
    if player is op:
        if in_game(player) is false:
            stop
        cancel event
