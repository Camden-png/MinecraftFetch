import:
    com.camden.skriptutils.Dict
    com.camden.skriptutils.Glow
    com.camden.skriptutils.Utils

options:
    patterns_dict: _create_patterns_dict()

function _create_patterns_dict() :: text:
    set {_dict} to new Dict()
    {_dict}.put("white", "white")
    # Blue, pink, white...
    {_dict}.put("trans", "aqua, light purple, white")
    set {_serialized} to {_dict}.serialize()
    return {_serialized}

command /glow:
    trigger:
        # TODO: move to inventory button player clicks...
        # TODO: add cycling logic...
        set {_key} to "trans"

        set {_dict} to Dict.deserialize({@patterns_dict})
        set {_colors} to {_dict}.get({_key}, null)
        if is_null({_colors}) is true:
            set {_key} to "unknown"
            set {_colors} to "white"

        set {_colors::*} to {_colors} split at ", "
        set {_length} to size of {_colors::*}

        set_key(player, "glow.pattern", {_key}) 
        set_key(player, "glow.colors", Utils.createSplitCommaList({_colors}))
        set_key(player, "glow.index", 0)  # Reset to 0...

        set {_now} to null
        if {_length} is greater than or equal to 2:
            set {_now} to Utils.getEpochTime()
        set_key(player, "glow.epoch_time", {_now})

command /unglow:
    trigger:
        # TODO: loop through all receivers...
        Glow.unsetGlow(player, player)
