import:
    com.camden.skriptutils.Dict
    com.camden.skriptutils.Glow

options:
    trans_colors: "aqua, light purple, white"  # Blue, pink, white...

# set {_serialized_glow_dict} to {_dict}.get("glow")
# set {_glow_dict} to Dict.deserialize({_serialized_glow_dict})
# {_dict}.put("glow", {_glow_dict})

function tester(player: player) :: object:
    set {_metadata} to {game::%{_player}%::metadata}
    set {_dict} to Dict.deserialize({_metadata})
    return {_dict}

function _recurse_update(player: player, key: text, value: object):
    set {_split::*} to {_key} split at "."
    set {_k} to first element of {_split::*}

    # Deserialize Dict...
    set {_metadata} to {game::%{_player}%::metadata}
    set {_dict} to Dict.deserialize({_metadata})

    # If length == 1...
    set {_length} to size of {_split::*}
    if {_length} is 1:
        {_dict}.put({_k}, {_value})
        set {_serialized} to {_dict}.serialize()
        set {game::%{_player}%::metadata} to {_serialized}
        stop

    # Emulate Python's maxsplit=1...
    set {_rest} to ""
    loop {_split::*}:
        set {_index} to loop-index parsed as number
        if {_index} is 1:
            continue

        clear {_suffix::*}
        if {_rest} is empty:
            set {_suffix::*} to loop-value
        else:
            set {_suffix::*} to "." and loop-value
        set {_rest} to join {_rest} and {_suffix::*} 

    # _recurse_update(a_dict[_key], rest, value)

function set_key_v2(player: player, key: text, value: object):
    _recurse_update({_player}, {_key}, {_value})

command /glow:
    trigger:
        set {_colors::*} to {@trans_colors} split at ", "        

        # broadcast "%{_colors::*}%"
        # set_key_v2(player, "has_bone", true)
        # set_key_v2(player, "glow.index", 1)  # 0-based...
        # Glow.setGlow(player, player, "red")
        set {_dict} to tester(player)
        broadcast "%{_dict}%"

command /unglow:
    trigger:
        Glow.unsetGlow(player, player)
