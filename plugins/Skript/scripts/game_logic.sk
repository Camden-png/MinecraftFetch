# === Game Logic ===

options:
    green: "light green"
    red: "light red"
    lobby_enum: export_lobby_enum()

import:
    com.camden.skriptutils.Dict

function check_has_bone(player: player):
    set {_has_bone} to false
    loop all items in {_player}'s inventory:
        if loop-item is bone:
            set {_has_bone} to true
            stop loop

    set {_old_status} to get_key({_player}, "has_bone")
    if {_old_status} is {_has_bone}:
        stop

    set_key({_player}, "has_bone", {_has_bone})

    # Apply / remove glow
    if {_has_bone} is true:
        apply_glow({_player})
    else:
        remove_glow({_player})

# Check if player has the bone...
every 3 ticks:
    loop all players:
        if in_game(loop-player, true) is true:  # Strict...
            check_has_bone(loop-player)

        # Passively update scoreboard
        if loop-player is op:
            set_scoreboard(loop-player)

# Check if lobby is ready...
every 5 ticks:
    set {_level_names::*} to get_levels()
    loop {_level_names::*}:
        set {_level_name} to loop-value

        set {_status} to get_key({_level_name}, "status")
        if {_status} is not {@lobby_enum}:
            continue

        set {_players_list} to get_key({_level_name}, "players")
        set {_players::*} to convert_to_skript_list({_players_list})  # Conver to Skript...

        # Avoid unlikely race condition...
        clear {_ready_players::*}  # Skript...
        loop {_players::*}:
            set {_player} to loop-value-2
            set {_player} to {_player} parsed as player
            set {_player_name} to "%{_player}%"

            set {_is_ready} to get_key({_player}, "is_ready")
            if {_is_ready} is true:
                add {_player_name} to {_ready_players::*}

        set {_metadata} to {level::%{_level_name}%::metadata}
        set {_dict} to Dict.deserialize({_metadata})
        set {_ready_players_list} to {_dict}.get("ready_players")

        {_ready_players_list}.clear()

        loop {_ready_players::*}:  # Cannot use `addAll(...)`...
            set {_player_name} to loop-value-2
            {_ready_players_list}.add({_player_name})

        {_dict}.put("ready_players", {_ready_players_list})

        set {_min_players} to get_key({_level_name}, "g_eq")
        set {_num_curr_players} to size of {_ready_players::*}
        loop {_players::*}:
            set {_player_name} to loop-value-2
            set {_player} to {_player_name} parsed as player
            set {_prefix} to "<%{@red}%>%{_num_curr_players}%/%{_min_players}%"
            set {_text} to "<%{@green}%><bold>Ready"
            set {_bar} to format_message({_prefix}, {_text})
            send action bar {_bar} to {_player}

        # Check enough players...
        set {_serialized} to {_dict}.serialize()
        set {level::%{_level_name}%::metadata} to {_serialized}
        if {_num_curr_players} is greater than or equal to {_min_players}:
            broadcast "Can start up game..."

on tool change:
    if in_lobby(player) is false:
        stop

    set {_old_status} to get_key(player, "is_ready")

    set {_is_ready} to false
    if tool is lime banner:
        set {_is_ready} to true

    if {_old_status} is {_is_ready}:
        stop

    set_key(player, "is_ready", {_is_ready})

# === Commands ===

function _leave(player: player, y_offset: number = 0):
    if in_game({_player}) is false:
        set {_message} to format_message("Error", "You are not in a game!", {@red})
        send {_message} to {_player}
        stop

    # In game...
    set {_level_name} to get_key({_player}, "level_name")
    _remove_player({_player}, {_level_name})

    if {_player} is online:
        _reset_player({_player}, true, {_y_offset})  # Hard
        set {_message} to format_message("Fetch", "You left a game!", {@green})
        send {_message} to {_player}

    # Update level status...
    set {_players_list} to get_key({_level_name}, "players")
    set {_length} to {_players_list}.size()
    if {_length} is 0:
        set_key({_level_name}, "status", null)

command /leave:
    trigger:
        _leave(player)

on rightclick holding an ender pearl:
    if in_lobby(player) is true:  # ONLY allow in lobby...
        _leave(player)
        cancel event

command /spawn [<text>]:
    trigger:
        set {_y_offset} to 0
        if player is op:
            if arg-1 is "debug":
                set {_y_offset} to 4

        if in_game(player) is true:
            _leave(player, {_y_offset})
            stop
        
        set {_message} to format_message("TP", "Teleported...", {@green})
        send {_message} to player
        tp_to_spawn(player, {_y_offset})

# === Edge-cases ===

# Item drop, item moves, etc.
on inventory click:
    if in_lobby(player) is true:
        cancel event

on drop:
    if in_lobby(player) is true:
        cancel event

on swap hand item:
    if in_lobby(player) is true:
        cancel event

on command "/clear":
    if player is not op:
        stop
    if in_game(player) is true:
        _leave(player)
        cancel event

on quit:
    if in_game(player) is true:
        _leave(player)
